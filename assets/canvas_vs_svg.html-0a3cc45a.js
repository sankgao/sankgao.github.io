import{_ as a,o as e,c as i,f as s}from"./app-9aab0a1e.js";const c={},n=s('<p>Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。</p><h2 id="svg" tabindex="-1"><a class="header-anchor" href="#svg" aria-hidden="true">#</a> SVG</h2><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><h2 id="canvas" tabindex="-1"><a class="header-anchor" href="#canvas" aria-hidden="true">#</a> canvas</h2><p>canvas 通过 JavaScript 来绘制 2D 图形。</p><p>canvas 是逐像素进行渲染的。</p><p>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><h2 id="canvas-与-svg-的比较" tabindex="-1"><a class="header-anchor" href="#canvas-与-svg-的比较" aria-hidden="true">#</a> Canvas 与 SVG 的比较</h2><p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><h3 id="canvas-1" tabindex="-1"><a class="header-anchor" href="#canvas-1" aria-hidden="true">#</a> canvas</h3><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 <code>.png</code> 或 <code>.jpg</code> 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><h3 id="svg-1" tabindex="-1"><a class="header-anchor" href="#svg-1" aria-hidden="true">#</a> SVG</h3><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul>',15),r=[n];function l(d,h){return e(),i("div",null,r)}const v=a(c,[["render",l],["__file","canvas_vs_svg.html.vue"]]);export{v as default};
