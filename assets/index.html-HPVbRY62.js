import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o as a,c as n,a as l,b as e,e as i,d as t,f as d}from"./app-0cCvii2M.js";const s="/assets/local-xRbZz__u.png",h="/assets/centralized-VwrkWPX1.png",p="/assets/distributed-CAGXGjsv.png",g={},u=e("p",null,"记录一些 Git 相关的信息。",-1),f=d('<h2 id="版本控制" tabindex="-1"><a class="header-anchor" href="#版本控制" aria-hidden="true">#</a> 版本控制</h2><p>版本控制（VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="本地版本控制系统" tabindex="-1"><a class="header-anchor" href="#本地版本控制系统" aria-hidden="true">#</a> 本地版本控制系统</h3><p>刚开始采用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。</p><p>为了解决这个问题，开发了本地版本控制系统（LVCS）。采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫 <code>RCS</code>，现今许多计算机系统上都还看得到它的踪影。<code>RCS</code> 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><figure><img src="'+s+'" alt="本地版本控制系统" tabindex="0" loading="lazy"><figcaption>本地版本控制系统</figcaption></figure><h3 id="集中化版本控制系统" tabindex="-1"><a class="header-anchor" href="#集中化版本控制系统" aria-hidden="true">#</a> 集中化版本控制系统</h3><p>本地版本控制系统只能让开发者在相同系统上协同工作，不同系统上开发者之间不能协同工作。</p><p>为了解决这个问题，开发了集中化版本控制系统（CVCS）。这类系统，如：<code>CVS</code>、<code>Subversion</code> 以及 <code>Perforce</code> 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>优点：每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>缺点：中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><figure><img src="'+h+'" alt="集中化版本控制系统" tabindex="0" loading="lazy"><figcaption>集中化版本控制系统</figcaption></figure><h3 id="分布式版本控制" tabindex="-1"><a class="header-anchor" href="#分布式版本控制" aria-hidden="true">#</a> 分布式版本控制</h3><p>为了解决中央服务器的单点故障，开发了分布式版本控制系统（DVCS）。在这类系统中，如：<code>Git</code>、<code>Mercurial</code> 以及 <code>Darcs</code> 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><p>许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，您就可以在同一个项目中，分别和不同工作小组的人相互协作。您可以根据需要设定不同的协作流程，比如：层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><figure><img src="'+p+'" alt="分布式版本控制" tabindex="0" loading="lazy"><figcaption>分布式版本控制</figcaption></figure><h2 id="git-由来" tabindex="-1"><a class="header-anchor" href="#git-由来" aria-hidden="true">#</a> Git 由来</h2><p><code>Linux</code> 内核开源项目有着为数众多的参与者。绝大多数的 <code>Linux</code> 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（<code>1991~2002</code> 年间）。到 <code>2002</code> 年，整个项目组开始启用一个专有的分布式版本控制系统 <code>BitKeeper</code> 来管理和维护代码。</p><p>到了 <code>2005</code> 年，开发 <code>BitKeeper</code> 的商业公司同 <code>Linux</code> 内核开源社区的合作关系结束，他们收回了 <code>Linux</code> 内核社区免费使用 <code>BitKeeper</code> 的权力。这就迫使 <code>Linux</code> 开源社区（特别是 <code>Linux</code> 的缔造者 <code>Linus Torvalds</code>）基于使用 <code>BitKeeper</code> 时的经验教训，开发出自己的版本系统（<code>Git</code>）。</p><p>他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 <code>Linux</code> 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 <code>2005</code> 年以来，<code>Git</code> 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p><h2 id="git-介绍" tabindex="-1"><a class="header-anchor" href="#git-介绍" aria-hidden="true">#</a> Git 介绍</h2>',23),_={href:"https://git-scm.com/",target:"_blank",rel:"noopener noreferrer"},G=d(`<p><code>Git</code> 易于学习，占用空间小，性能快如闪电。它凭借廉价的本地分支、方便的暂存区域和多个工作流程等功能，超越了 <code>Subversion</code>、<code>CVS</code>、<code>Perforce</code> 和 <code>ClearCase</code> 等 <code>SCM</code> 工具。</p><h3 id="git-保证完整性" tabindex="-1"><a class="header-anchor" href="#git-保证完整性" aria-hidden="true">#</a> Git 保证完整性</h3><p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 不可或缺的部分。若您在传送过程中丢失信息或损坏文件，Git 就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希），也称 <code>commit id</code>。这是一个由 <code>40</code> 个十六进制字符（<code>0-9</code> 和 <code>a-f</code>）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。SHA-1 哈希看起来是这样：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Git 中使用这种哈希值的情况很多，您将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h3 id="git-特性" tabindex="-1"><a class="header-anchor" href="#git-特性" aria-hidden="true">#</a> Git 特性</h3><ul><li>直接记录快照，而非差异比较</li><li>近乎所有操作都是本地执行</li><li><code>Git</code> 保证完整性</li><li><code>Git</code> 一般只添加数据</li><li>三种状态 <ul><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li></ul></li></ul><h3 id="git-三个阶段" tabindex="-1"><a class="header-anchor" href="#git-三个阶段" aria-hidden="true">#</a> Git 三个阶段</h3><p><code>Git</code> 的三种状态这会让我们的 <code>Git</code> 项目拥有三个阶段：工作区、暂存区以及 <code>Git</code> 仓库目录。</p><ul><li><strong>工作区</strong>：是对项目的某个版本独立提取出来的内容。这些从 <code>Git</code> 仓库的压缩数据库中提取出来的文件，放在磁盘上供您使用或修改</li><li><strong>暂存区</strong>：是一个文件，保存了下次将要提交的文件列表信息，一般在 <code>Git</code> 仓库目录中。按照 <code>Git</code> 的术语叫做 “索引”，不过一般说法还是叫 “暂存区”</li><li><strong>Git 仓库目录</strong>：是 <code>Git</code> 用来保存项目的元数据和对象数据库的地方。这是 <code>Git</code> 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h3 id="基本-git-工作流程" tabindex="-1"><a class="header-anchor" href="#基本-git-工作流程" aria-hidden="true">#</a> 基本 Git 工作流程</h3><ol><li>在工作区中修改文件</li><li>将您想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 <code>Git</code> 目录</li></ol><p>如果 <code>Git</code> 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。</p><h2 id="相关文档" tabindex="-1"><a class="header-anchor" href="#相关文档" aria-hidden="true">#</a> 相关文档</h2>`,15),b={href:"https://git-scm.com/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://git-scm.com/book/zh/v2",target:"_blank",rel:"noopener noreferrer"},x={href:"https://git-scm.com/docs",target:"_blank",rel:"noopener noreferrer"},C={href:"https://git-scm.com/downloads",target:"_blank",rel:"noopener noreferrer"},S={href:"https://github.com/git/git",target:"_blank",rel:"noopener noreferrer"},k={href:"https://learngitbranching.js.org/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://github.com/gotgit/gotgit/tree/master",target:"_blank",rel:"noopener noreferrer"};function V(L,B){const o=c("ExternalLinkIcon");return a(),n("div",null,[u,l(" more "),f,e("p",null,[e("a",_,[i("Git"),t(o)]),i(" 是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小到大的项目。")]),G,e("ul",null,[e("li",null,[e("a",b,[i("Git 官网"),t(o)])]),e("li",null,[e("a",m,[i("Git 官网 Pro Git 书籍教程"),t(o)])]),e("li",null,[e("a",x,[i("Git 官网参考手册"),t(o)])]),e("li",null,[e("a",C,[i("Git 官网下载"),t(o)])]),e("li",null,[e("a",S,[i("Git GitHub 地址"),t(o)])]),e("li",null,[e("a",k,[i("在线交互式 Git 分支可视化教程及练习"),t(o)])]),e("li",null,[i("《Git 权威指南》 "),e("a",v,[i("GitHub 地址"),t(o)])])])])}const H=r(g,[["render",V],["__file","index.html.vue"]]);export{H as default};
