import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as c,c as a,b as e,e as r,d,f as n}from"./app-LDyFvfhG.js";const s="/assets/gerrit-workflow-9ilMf6AH.png",l={},h=e("h2",{id:"历史",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#历史","aria-hidden":"true"},"#"),r(" 历史")],-1),p={href:"https://www.gerritcodereview.com/index.html",target:"_blank",rel:"noopener noreferrer"},f=e("strong",null,"赫里特·里特费尔德",-1),m=e("code",null,"Gerrit Code Review",-1),g={href:"https://github.com/rietveld-codereview/rietveld",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"Rietveld",-1),u=n('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p><code>Gerrit</code> 一种开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件开发者，可以相互审阅彼此修改后的代码，决定是否能够提交，回退或是继续修改。它使用版本控制系统 <code>Git</code> 作为底层。</p><h2 id="技术迭代" tabindex="-1"><a class="header-anchor" href="#技术迭代" aria-hidden="true">#</a> 技术迭代</h2><p>最早它是由 <code>Python</code> 写成，在 <code>Gerrit 2.x</code> 后，改成用 <code>Java</code> 与 <code>SQL</code>。使用 <strong>Google Web Toolkit</strong>（GWT） 来产生前端的 <code>JavaScript</code>。由于 <code>Gerrit 3.x</code> 中 <code>NoteDb</code> 取代了 <code>SQL</code> 数据库，所有元数据现在都存储在 <code>Git</code> 中。用户界面从 <code>GWT</code> 迁移到 <code>Polymer</code>。</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p>Gerrit 大致的工作流程：</p><ul><li>编写代码</li><li>将代码提交到暂存区（git add）</li><li>将暂存区的内容提交到本地仓库（git commit）</li><li>将本地仓库推送到 Gerrit 服务器中（git push）</li><li>审核人员审核代码</li><li>审核通过后提交到代码仓库</li></ul><figure><img src="'+s+`" alt="Gerrit 工作流程" tabindex="0" loading="lazy"><figcaption>Gerrit 工作流程</figcaption></figure><h2 id="修改提交检测" tabindex="-1"><a class="header-anchor" href="#修改提交检测" aria-hidden="true">#</a> 修改提交检测</h2><p>Git 提供了一种持续更新提交直到完美的机制，用 <code>git commit --amend</code> 命令重新制作（重新记录）代码更改。以这种方式更新提交后，您的分支就会指向新的提交。但是，较旧的（不完美的）修订版本不会丢失。可以通过 <code>git reflog</code> 命令找到。</p><p>当您将更改推送到 Gerrit 时，Gerrit 无法使用 <code>SHA-1</code>，因为该值在 <code>git commit --amend</code> 调用时会发生变化。</p><p>Gerrit 通过提交消息中的页脚来标识概念性更改。每个提交消息页脚都包含一个 <code>Change-Id</code> 消息挂钩，它唯一标识其所有草稿中的更改。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Change-Id: I9e29f5469142cc7fce9e90b0b09f5d2186ff0990
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因此，如果 <code>Change-Id</code> 在提交修改时保持不变，Gerrit 会检测到每个新版本都引用相同的概念更改。Gerrit Web 界面对版本进行分组，以便审阅者可以在代码审阅期间看到您的更改如何演变。</p><p>对于 Gerrit 来说，标识符可以是随机的。</p><h2 id="提交到-gerrit-特有分支" tabindex="-1"><a class="header-anchor" href="#提交到-gerrit-特有分支" aria-hidden="true">#</a> 提交到 Gerrit 特有分支</h2><p>Gerrit 提供一个特有的分支 <code>refs/for/*</code> 用来区分 <code>commit</code> 是提交到 Gerrit 服务器进行审核还是直接提交到远程 Git 仓库。</p><p>假如一个远程分支为 <code>master</code>，只有当代码被提交到 <code>refs/for/master</code> 分支时，Gerrit 才会知道，我收到了一个需要审核的代码推送，需要通知审核员来审核代码。当审核通过之后，Gerrit 会自动将这条分支合并到 <code>master</code> 主线上，然后邮件通知相关成员，<code>master</code> 分支有更新，需要的成员再去 <code>pull</code> 就好了。</p>`,18);function G(b,v){const o=i("ExternalLinkIcon");return c(),a("div",null,[h,e("p",null,[e("a",p,[r("Gerrit"),d(o)]),r(" 名字来自于荷兰设计师 "),f,r("（Gerrit Rietveld）。")]),e("p",null,[m,r(" 最初是 "),e("a",g,[r("Rietveld"),d(o)]),r(" 的一组简单补丁，最初是为了服务 Android 开源项目（AOSP）而构建的。因为对访问控制（ACL）相关的修正，而没有被集成到 "),_,r(" 中，由于功能和代码开始变得截然不同，因此需要不同的名称。")]),u])}const w=t(l,[["render",G],["__file","introduction.html.vue"]]);export{w as default};
